# -*- coding: utf-8 -*-
"""load.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16nhbYH4BOxKqXA-IARm2Uk6b09gHdxp_
"""

import numpy as np
import scipy.sparse as sp
import torch

device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

class Load_Data_Construct_A_For_GNN():
  def __init__(self, dir1, dir2, device):
    super().__init__()
    self.dir1 = dir1
    self.dir2 = dir2
    self.device = device

  def load_data(self):
    contents = np.genfromtxt(self.dir1, dtype=np.dtype(str))
    cites = np.genfromtxt(self.dir2, dtype=np.int32)
    fts = torch.FloatTensor(self.normalize(sp.csr_matrix(contents[:, 1:-1].astype(np.float32))).todense()).to(self.device)
    lbls = self.one_hot(contents[:, -1])
    edge_dict = {j:i for i, j in enumerate(np.array(contents[:, 0], dtype=np.int32))}
    edge_map = np.array(list(map(edge_dict.get, cites.flatten()))).reshape(cites.shape)
    adj = sp.coo_matrix((np.ones(edge_map.shape[0]), (edge_map[:, 0], edge_map[:, 1])),
                        shape=(lbls.shape[0], lbls.shape[0]))
    adj = adj + adj.T.multiply(adj.T > adj) - adj.multiply(adj.T > adj)
    adj = self.normalize(adj + sp.eye(adj.shape[0]))
    A = self.sparse_to_tensor(adj).to(self.device)
    labels = torch.LongTensor(np.where(lbls)[1]).to(self.device)
    idx_train = torch.LongTensor(range(140))
    idx_val = torch.LongTensor(range(200, 1000))
    idx_test = torch.LongTensor(range(1000, 1500))

    return fts, labels, A, idx_train, idx_val, idx_test


  def one_hot(self, lbls):
    classes = set(lbls)
    classes_dict = {j:np.identity(len(classes))[i, :] for i, j in enumerate(classes)}
    classes_map = np.array(list(map(classes_dict.get, lbls)), dtype=np.int32)
    return classes_map

  def normalize(self, mx):
    row_sum = np.array(mx.sum(1), dtype=np.float32)
    row_inv = np.power(row_sum, -1).flatten()
    row_inv[np.isinf(row_inv)] = 0
    degree_mx = sp.diags(row_inv)
    return degree_mx.dot(mx)

  def sparse_to_tensor(self, mx):
    mx = mx.tocoo().astype(np.float32)
    indices = torch.from_numpy(np.vstack((mx.row, mx.col)).astype(np.int64))
    data = torch.from_numpy(mx.data)
    shape = torch.Size(mx.shape)
    return torch.sparse_coo_tensor(indices, data, shape)